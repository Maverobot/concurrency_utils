/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#pragma once

#include <atomic>
#include <memory>

namespace realtime_utils {
template <typename T>
class LockFreeQueue {
 public:
  LockFreeQueue() : head_(new Node), tail_(head_.load()) {}

  ~LockFreeQueue() {
    while (Node* const old_head = head_.load()) {
      head_.store(old_head->next);
      delete old_head;
    }
  }

  LockFreeQueue(const LockFreeQueue& other) = delete;
  LockFreeQueue& operator=(const LockFreeQueue& other) = delete;

  // Pop a value from head
  std::shared_ptr<T> pop() {
    Node* old_head = popHead();
    if (!old_head) {
      return std::shared_ptr<T>();
    }
    std::shared_ptr<T> const res(old_head->data);
    delete old_head;
    return res;
  }

  // Push a new value to tail
  void push(T new_value) {
    std::shared_ptr<T> new_data(std::make_shared<T>(std::move(new_value)));

    // Add data into the old tail which was empty
    Node* const old_tail = tail_.load();
    old_tail->data.swap(new_data);

    // Let the old tail point to a new empty node
    Node* empty_node = new Node;
    old_tail->next = empty_node;

    // Finally save the empty node as tail
    tail_.store(empty_node);
  }

 private:
  struct Node {
    Node() : next(nullptr) {}
    std::shared_ptr<T> data;
    Node* next;
  };

  std::atomic<Node*> head_;
  std::atomic<Node*> tail_;

  Node* popHead() {
    // Get old head
    Node* const old_head = head_.load();
    if (old_head == tail_.load()) {
      return nullptr;
    }
    // Let the next node be the new head
    head_.store(old_head->next);
    return old_head;
  }
};
}  // namespace realtime_utils
